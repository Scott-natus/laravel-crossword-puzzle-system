<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use App\Models\PuzzleLevel;
use App\Services\PuzzleGridTemplateService;

class GridTemplateController extends Controller
{
    protected $templateService;

    public function __construct(PuzzleGridTemplateService $templateService)
    {
        $this->templateService = $templateService;
    }

    /**
     * 그리드 템플릿 생성 페이지
     */
    public function create()
    {
        // 모든 레벨 정보 가져오기
        $levels = DB::table('puzzle_levels')
            ->orderBy('level')
            ->get();

        return view('puzzle.grid-templates.create', compact('levels'));
    }

    /**
     * 레벨 선택 시 조건 정보 반환 (AJAX)
     */
    public function getLevelConditions(Request $request)
    {
        $levelId = $request->input('level_id');
        
        $level = DB::table('puzzle_levels')
            ->where('id', $levelId)
            ->first();

        if (!$level) {
            return response()->json([
                'success' => false,
                'message' => '레벨을 찾을 수 없습니다.'
            ]);
        }

        // 해당 레벨의 기존 템플릿들 가져오기
        $existingTemplates = DB::table('puzzle_grid_templates')
            ->where('level_id', $levelId)
            ->where('is_active', true)
            ->orderBy('created_at', 'desc')
            ->get();

        return response()->json([
            'success' => true,
            'level' => $level,
            'existing_templates' => $existingTemplates
        ]);
    }

    /**
     * 그리드 템플릿 저장
     */
    public function store(Request $request)
    {
        $request->validate([
            'level_id' => 'required|integer|exists:puzzle_levels,id',
            'grid_size' => 'required|integer|min:3|max:20',
            'grid_pattern' => 'required|array',
            'word_positions' => 'required|array',
            'word_count' => 'required|integer|min:1',
            'intersection_count' => 'required|integer|min:0'
        ]);

        try {
            // 레벨 정보 가져오기
            $level = DB::table('puzzle_levels')
                ->where('id', $request->level_id)
                ->first();

            if (!$level) {
                return response()->json([
                    'success' => false,
                    'message' => '레벨을 찾을 수 없습니다.'
                ]);
            }

            // 조건 검증
            if ($request->word_count != $level->word_count) {
                return response()->json([
                    'success' => false,
                    'message' => "단어 개수가 일치하지 않습니다. 레벨 {$level->level}은 {$level->word_count}개 단어가 필요합니다."
                ]);
            }

            if ($request->intersection_count != $level->intersection_count) {
                return response()->json([
                    'success' => false,
                    'message' => "교차점 개수가 일치하지 않습니다. 레벨 {$level->level}은 {$level->intersection_count}개 교차점이 필요합니다."
                ]);
            }

            // 템플릿 이름 자동 생성
            $templateCount = DB::table('puzzle_grid_templates')
                ->where('level_id', $request->level_id)
                ->count();
            
            $templateName = "레벨 {$level->level} 템플릿 #" . ($templateCount + 1);

            // 템플릿 데이터 준비
            $template = [
                'level_id' => $request->level_id,
                'template_name' => $templateName,
                'grid_pattern' => $request->grid_pattern,
                'word_positions' => $request->word_positions,
                'grid_width' => $request->grid_size,
                'grid_height' => $request->grid_size,
                'difficulty_rating' => $level->word_difficulty,
                'word_count' => $request->word_count,
                'intersection_count' => $request->intersection_count,
                'category' => 'custom',
                'description' => null,
                'is_active' => true
            ];

            // 템플릿 저장
            $templateId = $this->templateService->saveTemplate($template);

            return response()->json([
                'success' => true,
                'message' => '그리드 템플릿이 성공적으로 저장되었습니다.',
                'template_id' => $templateId
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => '템플릿 저장 중 오류가 발생했습니다: ' . $e->getMessage()
            ]);
        }
    }

    /**
     * 그리드 템플릿 목록
     */
    public function index()
    {
        $templates = DB::table('puzzle_grid_templates')
            ->join('puzzle_levels', 'puzzle_grid_templates.level_id', '=', 'puzzle_levels.id')
            ->select(
                'puzzle_grid_templates.*',
                'puzzle_levels.level',
                'puzzle_levels.level_name'
            )
            ->where('puzzle_grid_templates.is_active', true)
            ->orderBy('puzzle_levels.level')
            ->orderBy('puzzle_grid_templates.created_at', 'desc')
            ->get()
            ->map(function ($template) {
                // created_at을 Carbon 객체로 변환
                $template->created_at = \Carbon\Carbon::parse($template->created_at);
                $template->updated_at = \Carbon\Carbon::parse($template->updated_at);
                return $template;
            });

        return view('puzzle.grid-templates.index', compact('templates'));
    }

    /**
     * 그리드 템플릿 상세 보기
     */
    public function show($id)
    {
        $template = DB::table('puzzle_grid_templates')
            ->join('puzzle_levels', 'puzzle_grid_templates.level_id', '=', 'puzzle_levels.id')
            ->select(
                'puzzle_grid_templates.*',
                'puzzle_levels.level',
                'puzzle_levels.level_name'
            )
            ->where('puzzle_grid_templates.id', $id)
            ->where('puzzle_grid_templates.is_active', true)
            ->first();

        if (!$template) {
            return redirect()->route('puzzle.grid-templates.index')
                ->with('error', '템플릿을 찾을 수 없습니다.');
        }

        // created_at을 Carbon 객체로 변환
        $template->created_at = \Carbon\Carbon::parse($template->created_at);
        $template->updated_at = \Carbon\Carbon::parse($template->updated_at);

        // JSON 데이터 파싱
        $gridPattern = json_decode($template->grid_pattern, true);
        $wordPositions = json_decode($template->word_positions, true);

        return view('puzzle.grid-templates.show', compact('template', 'gridPattern', 'wordPositions'));
    }

    /**
     * 그리드 템플릿 삭제
     */
    public function destroy($id)
    {
        try {
            $template = DB::table('puzzle_grid_templates')
                ->where('id', $id)
                ->where('is_active', true)
                ->first();

            if (!$template) {
                return response()->json([
                    'success' => false,
                    'message' => '템플릿을 찾을 수 없습니다.'
                ]);
            }

            // 논리적 삭제 (is_active = false)
            DB::table('puzzle_grid_templates')
                ->where('id', $id)
                ->update(['is_active' => false]);

            return response()->json([
                'success' => true,
                'message' => '템플릿이 성공적으로 삭제되었습니다.'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => '템플릿 삭제 중 오류가 발생했습니다: ' . $e->getMessage()
            ]);
        }
    }

    /**
     * 단어 추출 - 템플릿에서 단어 배치 순서 추출
     */
    public function extractWords(Request $request)
    {
        $request->validate([
            'template_id' => 'required|exists:puzzle_grid_templates,id'
        ]);

        try {
            $template = DB::table('puzzle_grid_templates')
                ->where('id', $request->template_id)
                ->where('is_active', true)
                ->first();

            if (!$template) {
                return response()->json([
                    'success' => false,
                    'message' => '템플릿을 찾을 수 없습니다.'
                ]);
            }

            $gridPattern = json_decode($template->grid_pattern, true);
            $wordPositions = json_decode($template->word_positions, true);
            
            // 새로운 넘버링 로직 적용 (저장된 정보 무시하고 재계산)
            $wordOrder = $this->applyNewNumberingLogic($wordPositions, $gridPattern, $template);
            
            return response()->json([
                'success' => true,
                'message' => '새로운 넘버링 로직으로 단어 배치 순서를 계산했습니다.',
                'template' => $template,
                'word_analysis' => [
                    'total_words' => count($wordPositions),
                    'word_positions' => $wordPositions
                ],
                'extracted_words' => [
                    'status' => 'new_numbering_applied',
                    'message' => '새로운 넘버링 로직으로 단어 배치 순서를 계산했습니다.',
                    'word_order' => $wordOrder,
                    'grid_info' => [
                        'width' => $template->grid_width,
                        'height' => $template->grid_height,
                        'pattern' => $gridPattern
                    ]
                ],
                'debug_info' => [
                    'algorithm_version' => 'new_numbering_logic',
                    'template_id' => $template->id,
                    'level_id' => $template->level_id
                ]
            ], 200, [], JSON_INVALID_UTF8_SUBSTITUTE);
            
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => '단어 배치 순서 계산 중 오류가 발생했습니다: ' . $e->getMessage(),
                'debug_info' => [
                    'error' => $e->getMessage(),
                    'trace' => $e->getTraceAsString()
                ]
            ], 500, [], JSON_INVALID_UTF8_SUBSTITUTE);
        }
    }
    
    /**
     * 새로운 넘버링 로직 적용
     */
    private function applyNewNumberingLogic($wordPositions, $gridPattern, $template)
    {
        $gridSize = count($gridPattern);
        $usedWords = [];
        $visitedPositions = [];
        $wordOrder = [];
        $orderNumber = 0; // 0부터 시작
        
        // 레벨 정보 가져오기
        $level = DB::table('puzzle_levels')->where('id', $template->level_id)->first();
        $maxWords = $level ? $level->word_count : 20;
        
        // 가로열 우선 순차 탐색 (좌측 맨위부터 가로열 진행)
        for ($y = 0; $y < $gridSize; $y++) {
            for ($x = 0; $x < $gridSize; $x++) {
                if ($orderNumber >= $maxWords) break; // 레벨별 단어 개수 제한
                
                $positionKey = "{$x},{$y}";
                if (in_array($positionKey, $visitedPositions)) continue;
                
                // 현재 위치가 검은색칸(단어가 있는 칸)인지 확인
                if ($gridPattern[$y][$x] === 2) {
                    // 이 위치에서 시작하는 단어들 찾기
                    $wordsAtPosition = $this->findWordsAtPosition($x, $y, $wordPositions, $usedWords);
                    
                    if (!empty($wordsAtPosition)) {
                        // 첫 번째로 만나는 단어를 넘버링 (NUMBERING+1)
                        $firstWord = $wordsAtPosition[0];
                        $firstWord['order'] = $orderNumber++;
                        $usedWords[] = $firstWord['id'];
                        $this->markWordPositionsAsVisited($firstWord, $visitedPositions);
                        
                        $wordOrder[] = [
                            'word_id' => $firstWord['id'],
                            'position' => $firstWord,
                            'type' => 'first_word',
                            'order' => $firstWord['order'],
                            'start_x' => $firstWord['start_x'],
                            'start_y' => $firstWord['start_y']
                        ];
                        
                        // 연쇄 교차점 처리: 연결된 단어들을 순차적으로 넘버링
                        $processedWords = [$firstWord['id']];
                        $currentWord = $firstWord;
                        
                        while ($orderNumber < $maxWords) {
                            $connectedWords = $this->findConnectedWordsByIntersection($currentWord, $wordPositions, $usedWords);
                            $foundNext = false;
                            
                            foreach ($connectedWords as $connectedWord) {
                                if (!in_array($connectedWord['id'], $processedWords)) {
                                    // 연결된 단어 넘버링 (NUMBERING+1)
                                    $connectedWord['order'] = $orderNumber++;
                                    $usedWords[] = $connectedWord['id'];
                                    $processedWords[] = $connectedWord['id'];
                                    $this->markWordPositionsAsVisited($connectedWord, $visitedPositions);
                                    
                                    $wordOrder[] = [
                                        'word_id' => $connectedWord['id'],
                                        'position' => $connectedWord,
                                        'type' => 'intersection_connected',
                                        'order' => $connectedWord['order'],
                                        'start_x' => $connectedWord['start_x'],
                                        'start_y' => $connectedWord['start_y']
                                    ];
                                    
                                    // 다음 연결 단어로 이동
                                    $currentWord = $connectedWord;
                                    $foundNext = true;
                                    break;
                                }
                            }
                            
                            // 더 이상 연결된 단어가 없으면 순차 탐색으로 복귀
                            if (!$foundNext) {
                                break;
                            }
                        }
                    }
                }
            }
            if ($orderNumber >= $maxWords) break; // 레벨별 단어 개수 제한
        }
        
        // 남은 단어들 처리 (교차점이 없는 단어들) - 순차 탐색으로 복귀
        for ($y = 0; $y < $gridSize && $orderNumber < $maxWords; $y++) {
            for ($x = 0; $x < $gridSize && $orderNumber < $maxWords; $x++) {
                $positionKey = "{$x},{$y}";
                if (in_array($positionKey, $visitedPositions)) continue;
                
                if ($gridPattern[$y][$x] === 2) {
                    $wordsAtPosition = $this->findWordsAtPosition($x, $y, $wordPositions, $usedWords);
                    
                    foreach ($wordsAtPosition as $word) {
                        if ($orderNumber >= $maxWords) break;
                        
                        $word['order'] = $orderNumber++;
                        $usedWords[] = $word['id'];
                        $this->markWordPositionsAsVisited($word, $visitedPositions);
                        
                        $wordOrder[] = [
                            'word_id' => $word['id'],
                            'position' => $word,
                            'type' => 'sequential_word',
                            'order' => $word['order'],
                            'start_x' => $word['start_x'],
                            'start_y' => $word['start_y']
                        ];
                    }
                }
            }
        }
        
        // order 순서대로 정렬
        usort($wordOrder, function($a, $b) {
            return $a['order'] - $b['order'];
        });
        
        return $wordOrder;
    }
    
    /**
     * 특정 위치에서 시작하는 단어들 찾기
     */
    private function findWordsAtPosition($x, $y, $wordPositions, $usedWords)
    {
        $words = [];
        
        foreach ($wordPositions as $word) {
            if (in_array($word['id'], $usedWords)) continue;
            
            // 가로 단어 확인
            if ($word['direction'] === 'horizontal' && 
                $word['start_x'] === $x && $word['start_y'] === $y) {
                $words[] = $word;
            }
            
            // 세로 단어 확인
            if ($word['direction'] === 'vertical' && 
                $word['start_x'] === $x && $word['start_y'] === $y) {
                $words[] = $word;
            }
        }
        
        return $words;
    }
    
    /**
     * 교차점으로 연결된 단어들 찾기
     */
    private function findConnectedWordsByIntersection($word, $wordPositions, $usedWords)
    {
        $connectedWords = [];
        
        foreach ($wordPositions as $otherWord) {
            if (in_array($otherWord['id'], $usedWords)) continue;
            if ($word['id'] === $otherWord['id']) continue;
            
            // 교차점 확인
            $intersection = $this->findIntersection($word, $otherWord);
            if ($intersection) {
                $connectedWords[] = $otherWord;
            }
        }
        
        return $connectedWords;
    }
    
    /**
     * 단어가 차지한 위치들을 방문된 것으로 표시
     */
    private function markWordPositionsAsVisited($word, &$visitedPositions)
    {
        if ($word['direction'] === 'horizontal') {
            for ($x = $word['start_x']; $x <= $word['end_x']; $x++) {
                $visitedPositions[] = "{$x},{$word['start_y']}";
            }
        } else {
            for ($y = $word['start_y']; $y <= $word['end_y']; $y++) {
                $visitedPositions[] = "{$word['start_x']},{$y}";
            }
        }
    }

    /**
     * 단어 제출 - 템플릿에 맞는 단어 추출 및 매칭
     */
    public function submitWords(Request $request)
    {
        $request->validate([
            'template_id' => 'required|exists:puzzle_grid_templates,id',
            'level_id' => 'required|exists:puzzle_levels,id'
        ]);

        try {
            // 템플릿 정보 가져오기
            $template = DB::table('puzzle_grid_templates')
                ->where('id', $request->template_id)
                ->where('is_active', true)
                ->first();

            if (!$template) {
                return response()->json([
                    'success' => false,
                    'message' => '템플릿을 찾을 수 없습니다.'
                ]);
            }

            // 레벨 정보 가져오기
            $level = DB::table('puzzle_levels')
                ->where('id', $request->level_id)
                ->first();

            if (!$level) {
                return response()->json([
                    'success' => false,
                    'message' => '레벨을 찾을 수 없습니다.'
                ]);
            }

            $gridPattern = json_decode($template->grid_pattern, true);
            $wordPositions = json_decode($template->word_positions, true);
            
            // 넘버링 순서대로 정렬
            usort($wordPositions, function($a, $b) {
                return ($a['order'] ?? 0) - ($b['order'] ?? 0);
            });

            // 단어 추출 및 매칭 실행
            $result = $this->extractAndMatchWords($wordPositions, $gridPattern, $level);
            
            return response()->json([
                'success' => true,
                'message' => '단어 추출 및 매칭이 완료되었습니다.',
                'template_name' => $template->template_name,
                'level_info' => "레벨 {$level->level} - {$level->level_name}",
                'total_words' => count($wordPositions),
                'matched_words' => $result['matched_count'],
                'failed_words' => $result['failed_count'],
                'conditions' => [
                    'word_difficulty' => "≤ {$level->word_difficulty}",
                    'hint_difficulty' => $level->hint_difficulty,
                    'intersection_handling' => '교차점 음절 매칭'
                ],
                'words' => $result['words'],
                'sql_queries' => $result['sql_queries']
            ], 200, [], JSON_INVALID_UTF8_SUBSTITUTE);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => '단어 추출 중 오류가 발생했습니다: ' . $e->getMessage(),
                'debug_info' => [
                    'error' => $e->getMessage(),
                    'trace' => $e->getTraceAsString()
                ]
            ], 500, [], JSON_INVALID_UTF8_SUBSTITUTE);
        }
    }
    
    /**
     * 단어 추출 및 매칭 로직 (개선된 버전)
     */
    private function extractAndMatchWords($wordPositions, $gridPattern, $level)
    {
        $extractedWords = [];
        $sqlQueries = [];
        $matchedCount = 0;
        $failedCount = 0;
        
        // 2번: 단어 번호 순서대로 정렬
        usort($wordPositions, function($a, $b) {
            return ($a['order'] ?? 0) - ($b['order'] ?? 0);
        });
        
        // 단어 순서대로 처리
        foreach ($wordPositions as $word) {
            try {
                // 이미 처리된 단어인지 확인
                $alreadyProcessed = false;
                foreach ($extractedWords as $extracted) {
                    if ($extracted['order'] == $word['order']) {
                        $alreadyProcessed = true;
                        break;
                    }
                }
                
                if ($alreadyProcessed) {
                    continue;
                }
                
                // 교차점이 있는지 확인
                $intersections = $this->findWordIntersections($word, $wordPositions);
                
                if (empty($intersections)) {
                    // 3번 로직: 독립 단어 처리
                    $result = $this->extractIndependentWord($word, $level);
                    $extractedWords[] = [
                        'order' => $word['order'],
                        'direction' => $word['direction'],
                        'length' => $word['length'],
                        'extracted_word' => $result['word'],
                        'hint' => $result['hint'],
                        'match_type' => 'independent'
                    ];
                    $sqlQueries[] = $result['sql'];
                    $matchedCount++;
                } else {
                    // 4번 로직: 교차점 단어 처리 (연쇄 처리 포함)
                    $result = $this->extractChainIntersectionWords($word, $intersections, $wordPositions, $level, $extractedWords);
                    if ($result['success']) {
                        // 연쇄 매칭된 모든 단어들을 추가
                        foreach ($result['matched_words'] as $matchedWord) {
                            $extractedWords[] = $matchedWord;
                        }
                        $sqlQueries = array_merge($sqlQueries, $result['sql_queries']);
                        $matchedCount += count($result['matched_words']);
                    } else {
                        $extractedWords[] = [
                            'order' => $word['order'],
                            'direction' => $word['direction'],
                            'length' => $word['length'],
                            'extracted_word' => '매칭 실패',
                            'hint' => $result['message'],
                            'match_type' => 'failed',
                            'debug_info' => $result['debug_info'] ?? null
                        ];
                        $failedCount++;
                    }
                }
            } catch (\Exception $e) {
                $extractedWords[] = [
                    'order' => $word['order'],
                    'direction' => $word['direction'],
                    'length' => $word['length'],
                    'extracted_word' => '오류 발생',
                    'hint' => $e->getMessage(),
                    'match_type' => 'error'
                ];
                $failedCount++;
            }
        }
        
        return [
            'words' => $extractedWords,
            'sql_queries' => $sqlQueries,
            'matched_count' => $matchedCount,
            'failed_count' => $failedCount
        ];
    }
    
    /**
     * 독립 단어 추출 (3번 로직)
     */
    private function extractIndependentWord($word, $level)
    {
        // 힌트 난이도 매핑
        $hintDifficultyMap = [
            '쉬움' => 'easy',
            '보통' => 'medium',
            '어려움' => 'hard'
        ];
        $hintDifficulty = $hintDifficultyMap[$level->hint_difficulty] ?? 'easy';
        
        $sql = "SELECT a.word, b.hint_text 
                FROM pz_words a 
                JOIN pz_hints b ON a.id = b.word_id 
                WHERE a.length = {$word['length']} 
                AND a.is_active = true 
                AND a.difficulty <= {$level->word_difficulty} 
                AND b.hint_type = 'text' 
                AND b.difficulty = '{$hintDifficulty}' 
                ORDER BY RANDOM() 
                LIMIT 1";
        
        $result = DB::select($sql);
        
        if (empty($result)) {
            throw new \Exception("조건에 해당하는 단어의 조합을 찾을 수 없습니다.");
        }
        
        return [
            'word' => $result[0]->word,
            'hint' => $result[0]->hint_text,
            'sql' => $sql
        ];
    }
    
    /**
     * 연쇄 교차점 단어 추출 (4번 로직 - 개선된 버전)
     */
    private function extractChainIntersectionWords($word, $intersections, $wordPositions, $level, $extractedWords)
    {
        // 힌트 난이도 매핑
        $hintDifficultyMap = [
            '쉬움' => 'easy',
            '보통' => 'medium',
            '어려움' => 'hard'
        ];
        $hintDifficulty = $hintDifficultyMap[$level->hint_difficulty] ?? 'easy';
        
        // 4-1: 단어(A) 조건에 맞는 100개 단어 추출
        $sql1 = "SELECT a.word 
                FROM pz_words a 
                JOIN pz_hints b ON a.id = b.word_id 
                WHERE a.length = {$word['length']} 
                AND a.is_active = true 
                AND a.difficulty <= {$level->word_difficulty} 
                AND b.hint_type = 'text' 
                AND b.difficulty = '{$hintDifficulty}' 
                ORDER BY RANDOM() 
                LIMIT 100";
        
        $candidates = DB::select($sql1);
        $sqlQueries = [$sql1];
        
        if (empty($candidates)) {
            return [
                'success' => false,
                'message' => '조건에 해당하는 단어의 조합을 찾을 수 없습니다.',
                'sql_queries' => $sqlQueries
            ];
        }
        
        // 첫 번째 교차점 처리
        $intersection = $intersections[0];
        $connectedWord = $this->findWordById($intersection['connected_word_id'], $wordPositions);
        
        // 4-2: 교차점에서 단어(A)의 음절 위치 추출
        $wordSyllablePos = $this->getSyllablePosition($word, $intersection['position']);
        
        // 4-3: 교차점에서 단어(B)의 음절 위치 추출
        $connectedSyllablePos = $this->getSyllablePosition($connectedWord, $intersection['position']);
        
        // 4-2: 배열1에서 음절 추출하여 str1 생성
        $syllables = [];
        foreach ($candidates as $candidate) {
            $syllable = mb_substr($candidate->word, $wordSyllablePos - 1, 1, 'UTF-8');
            if (!empty($syllable)) {
                $syllables[] = "'" . addslashes($syllable) . "'";
            }
        }
        
        if (empty($syllables)) {
            return [
                'success' => false,
                'message' => '유효한 음절을 추출할 수 없습니다.',
                'sql_queries' => $sqlQueries
            ];
        }
        
        // 4-4: 단어(B) 추출 쿼리
        $str1 = implode(',', $syllables);
        $sql2 = "SELECT a.word, b.hint_text 
                FROM pz_words a 
                JOIN pz_hints b ON a.id = b.word_id 
                WHERE SUBSTRING(a.word, {$connectedSyllablePos}, 1) IN ({$str1}) 
                AND a.length = {$connectedWord['length']} 
                AND a.is_active = true 
                AND a.difficulty <= {$level->word_difficulty} 
                AND b.hint_type = 'text' 
                AND b.difficulty = '{$hintDifficulty}' 
                ORDER BY RANDOM() 
                LIMIT 100";
        
        $connectedCandidates = DB::select($sql2);
        $sqlQueries[] = $sql2;
        
        if (empty($connectedCandidates)) {
            return [
                'success' => false,
                'message' => '교차점 매칭을 위한 단어를 찾을 수 없습니다.',
                'sql_queries' => $sqlQueries
            ];
        }
        
        // 4-6: 두 번째 교차점 확인
        $secondIntersections = $this->findWordIntersections($connectedWord, $wordPositions);
        $secondIntersections = array_filter($secondIntersections, function($intersection) use ($word) {
            return $intersection['connected_word_id'] != $word['id'];
        });
        
        if (empty($secondIntersections)) {
            // 4-5: 단순 2개 단어 매칭
            return $this->matchTwoWords($candidates, $connectedCandidates, $word, $connectedWord, $wordSyllablePos, $connectedSyllablePos, $sqlQueries);
        } else {
            // 4-6~4-9: 연쇄 3개 단어 매칭
            return $this->matchThreeWords($candidates, $connectedCandidates, $word, $connectedWord, $secondIntersections[0], $wordPositions, $level, $hintDifficulty, $sqlQueries);
        }
    }
    
    /**
     * 단어의 교차점 찾기
     */
    private function findWordIntersections($word, $wordPositions)
    {
        $intersections = [];
        
        foreach ($wordPositions as $otherWord) {
            if ($word['id'] === $otherWord['id']) continue;
            
            $intersection = $this->findIntersection($word, $otherWord);
            if ($intersection) {
                $intersections[] = [
                    'position' => $intersection,
                    'connected_word_id' => $otherWord['id']
                ];
            }
        }
        
        return $intersections;
    }
    
    /**
     * ID로 단어 찾기
     */
    private function findWordById($id, $wordPositions)
    {
        foreach ($wordPositions as $word) {
            if ($word['id'] == $id) {
                return $word;
            }
        }
        return null;
    }
    
    /**
     * 교차점에서의 음절 위치 계산
     */
    private function getSyllablePosition($word, $intersection)
    {
        if ($word['direction'] === 'horizontal') {
            return $intersection['x'] - $word['start_x'] + 1;
        } else {
            return $intersection['y'] - $word['start_y'] + 1;
        }
    }

    /**
     * 2개 단어 매칭 (4-5번 로직)
     */
    private function matchTwoWords($candidates, $connectedCandidates, $word, $connectedWord, $wordSyllablePos, $connectedSyllablePos, $sqlQueries)
    {
        $matchAttempts = 0;
        $successfulMatches = 0;
        
        foreach ($candidates as $candidate) {
            $candidateSyllable = mb_substr($candidate->word, $wordSyllablePos - 1, 1, 'UTF-8');
            
            foreach ($connectedCandidates as $connectedCandidate) {
                $matchAttempts++;
                $connectedSyllable = mb_substr($connectedCandidate->word, $connectedSyllablePos - 1, 1, 'UTF-8');
                
                // 디버깅 로그 추가
                if ($matchAttempts <= 5) {
                    \Log::info("2개 단어 매칭 시도 #{$matchAttempts}: '{$candidateSyllable}' vs '{$connectedSyllable}' (단어A: {$candidate->word}, 단어B: {$connectedCandidate->word})");
                }
                
                if ($candidateSyllable === $connectedSyllable) {
                    $successfulMatches++;
                    \Log::info("2개 단어 매칭 성공! 단어A: {$candidate->word}, 단어B: {$connectedCandidate->word}, 공통 음절: {$candidateSyllable}");
                    
                    return [
                        'success' => true,
                        'matched_words' => [
                            [
                                'order' => $word['order'],
                                'direction' => $word['direction'],
                                'length' => $word['length'],
                                'extracted_word' => $candidate->word,
                                'hint' => $candidate->hint_text ?? '힌트 없음',
                                'match_type' => 'intersection_2'
                            ],
                            [
                                'order' => $connectedWord['order'],
                                'direction' => $connectedWord['direction'],
                                'length' => $connectedWord['length'],
                                'extracted_word' => $connectedCandidate->word,
                                'hint' => $connectedCandidate->hint_text ?? '힌트 없음',
                                'match_type' => 'intersection_2'
                            ]
                        ],
                        'sql_queries' => $sqlQueries,
                        'debug_info' => [
                            'match_attempts' => $matchAttempts,
                            'successful_matches' => $successfulMatches,
                            'candidate_syllable' => $candidateSyllable,
                            'connected_syllable' => $connectedSyllable
                        ]
                    ];
                }
            }
        }
        
        \Log::warning("2개 단어 매칭 실패: 총 {$matchAttempts}번 시도, 성공: {$successfulMatches}번");
        
        return [
            'success' => false,
            'message' => '교차점 매칭 조건을 만족하는 단어 조합을 찾을 수 없습니다.',
            'sql_queries' => $sqlQueries,
            'debug_info' => [
                'match_attempts' => $matchAttempts,
                'successful_matches' => $successfulMatches,
                'candidates_count' => count($candidates),
                'connected_candidates_count' => count($connectedCandidates)
            ]
        ];
    }
    
    /**
     * 3개 단어 연쇄 매칭 (4-6~4-9번 로직)
     */
    private function matchThreeWords($candidates, $connectedCandidates, $word, $connectedWord, $secondIntersection, $wordPositions, $level, $hintDifficulty, $sqlQueries)
    {
        $thirdWord = $this->findWordById($secondIntersection['connected_word_id'], $wordPositions);
        
        // 4-6: 두 번째 교차점에서 단어(B)의 음절 위치 추출
        $connectedSyllablePos2 = $this->getSyllablePosition($connectedWord, $secondIntersection['position']);
        
        // 4-6: 배열2에서 음절 추출하여 str2 생성
        $syllables2 = [];
        foreach ($connectedCandidates as $connectedCandidate) {
            $syllable = mb_substr($connectedCandidate->word, $connectedSyllablePos2 - 1, 1, 'UTF-8');
            if (!empty($syllable)) {
                $syllables2[] = "'" . addslashes($syllable) . "'";
            }
        }
        
        if (empty($syllables2)) {
            return [
                'success' => false,
                'message' => '두 번째 교차점에서 유효한 음절을 추출할 수 없습니다.',
                'sql_queries' => $sqlQueries
            ];
        }
        
        // 4-7: 두 번째 교차점에서 단어(C)의 음절 위치 추출
        $thirdSyllablePos = $this->getSyllablePosition($thirdWord, $secondIntersection['position']);
        
        // 4-8: 단어(C) 추출 쿼리
        $str2 = implode(',', $syllables2);
        $sql3 = "SELECT a.word, b.hint_text 
                FROM pz_words a 
                JOIN pz_hints b ON a.id = b.word_id 
                WHERE SUBSTRING(a.word, {$thirdSyllablePos}, 1) IN ({$str2}) 
                AND a.length = {$thirdWord['length']} 
                AND a.is_active = true 
                AND a.difficulty <= {$level->word_difficulty} 
                AND b.hint_type = 'text' 
                AND b.difficulty = '{$hintDifficulty}' 
                ORDER BY RANDOM() 
                LIMIT 100";
        
        $thirdCandidates = DB::select($sql3);
        $sqlQueries[] = $sql3;
        
        if (empty($thirdCandidates)) {
            return [
                'success' => false,
                'message' => '세 번째 단어 매칭을 위한 단어를 찾을 수 없습니다.',
                'sql_queries' => $sqlQueries
            ];
        }
        
        // 4-9: 3개 단어 연쇄 매칭
        $matchAttempts = 0;
        $successfulMatches = 0;
        
        foreach ($candidates as $candidate) {
            $candidateSyllable = mb_substr($candidate->word, $this->getSyllablePosition($word, $secondIntersection['position']) - 1, 1, 'UTF-8');
            
            foreach ($connectedCandidates as $connectedCandidate) {
                $connectedSyllable1 = mb_substr($connectedCandidate->word, $this->getSyllablePosition($connectedWord, $secondIntersection['position']) - 1, 1, 'UTF-8');
                $connectedSyllable2 = mb_substr($connectedCandidate->word, $connectedSyllablePos2 - 1, 1, 'UTF-8');
                
                foreach ($thirdCandidates as $thirdCandidate) {
                    $matchAttempts++;
                    $thirdSyllable = mb_substr($thirdCandidate->word, $thirdSyllablePos - 1, 1, 'UTF-8');
                    
                    // 디버깅 로그 추가
                    if ($matchAttempts <= 5) {
                        \Log::info("3개 단어 매칭 시도 #{$matchAttempts}: A='{$candidateSyllable}', B1='{$connectedSyllable1}', B2='{$connectedSyllable2}', C='{$thirdSyllable}'");
                    }
                    
                    if ($candidateSyllable === $connectedSyllable1 && $connectedSyllable2 === $thirdSyllable) {
                        $successfulMatches++;
                        \Log::info("3개 단어 매칭 성공! A: {$candidate->word}, B: {$connectedCandidate->word}, C: {$thirdCandidate->word}");
                        
                        return [
                            'success' => true,
                            'matched_words' => [
                                [
                                    'order' => $word['order'],
                                    'direction' => $word['direction'],
                                    'length' => $word['length'],
                                    'extracted_word' => $candidate->word,
                                    'hint' => $candidate->hint_text ?? '힌트 없음',
                                    'match_type' => 'intersection_3'
                                ],
                                [
                                    'order' => $connectedWord['order'],
                                    'direction' => $connectedWord['direction'],
                                    'length' => $connectedWord['length'],
                                    'extracted_word' => $connectedCandidate->word,
                                    'hint' => $connectedCandidate->hint_text ?? '힌트 없음',
                                    'match_type' => 'intersection_3'
                                ],
                                [
                                    'order' => $thirdWord['order'],
                                    'direction' => $thirdWord['direction'],
                                    'length' => $thirdWord['length'],
                                    'extracted_word' => $thirdCandidate->word,
                                    'hint' => $thirdCandidate->hint_text ?? '힌트 없음',
                                    'match_type' => 'intersection_3'
                                ]
                            ],
                            'sql_queries' => $sqlQueries,
                            'debug_info' => [
                                'match_attempts' => $matchAttempts,
                                'successful_matches' => $successfulMatches,
                                'chain_type' => 'A-B-C'
                            ]
                        ];
                    }
                }
            }
        }
        
        \Log::warning("3개 단어 매칭 실패: 총 {$matchAttempts}번 시도, 성공: {$successfulMatches}번");
        
        return [
            'success' => false,
            'message' => '3개 단어 연쇄 매칭 조건을 만족하는 단어 조합을 찾을 수 없습니다.',
            'sql_queries' => $sqlQueries,
            'debug_info' => [
                'match_attempts' => $matchAttempts,
                'successful_matches' => $successfulMatches,
                'candidates_count' => count($candidates),
                'connected_candidates_count' => count($connectedCandidates),
                'third_candidates_count' => count($thirdCandidates)
            ]
        ];
    }

    /**
     * 두 단어 간의 교차점 찾기
     */
    private function findIntersection($word1, $word2)
    {
        if ($word1['direction'] === 'horizontal' && $word2['direction'] === 'vertical') {
            $horizontal = $word1;
            $vertical = $word2;
            
            if ($horizontal['start_y'] >= $vertical['start_y'] && $horizontal['start_y'] <= $vertical['end_y'] &&
                $vertical['start_x'] >= $horizontal['start_x'] && $vertical['start_x'] <= $horizontal['end_x']) {
                return [
                    'x' => $vertical['start_x'],
                    'y' => $horizontal['start_y']
                ];
            }
        } else if ($word1['direction'] === 'vertical' && $word2['direction'] === 'horizontal') {
            $vertical = $word1;
            $horizontal = $word2;
            
            if ($horizontal['start_y'] >= $vertical['start_y'] && $horizontal['start_y'] <= $vertical['end_y'] &&
                $vertical['start_x'] >= $horizontal['start_x'] && $vertical['start_x'] <= $horizontal['end_x']) {
                return [
                    'x' => $vertical['start_x'],
                    'y' => $horizontal['start_y']
                ];
            }
        }
        
        return null;
    }
} 